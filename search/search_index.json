{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro","text":""},{"location":"#spatial-network-analysis-python-module","title":"Spatial Network Analysis Python Module","text":"<p>A package of spatial network analysis tools based on Geopandas dataframe and custom pathfinding (SGACy). Developed for regional scale spatial network analysis in Python environment for efficiency and better documentation. Fast performance utilizing Cython optimized algorithms and capabilities for multithreading using multiprocessing.pool. Most functions and tools are based from Urban Network Analysis Toolbox by MIT City Form Lab.</p> <p>This is a documentation of the   SNAPy library</p> <p> sample output page here</p>"},{"location":"#authorship","title":"Authorship","text":"<p>made by kevinsutjijadi @2023 Jakarta, Indonesia Last updated at 2024/09/27</p>"},{"location":"#installation","title":"Installation","text":"<p>available on pypi latest version is 0.2.14 (https://pypi.org/project/snapy-toolbox/) <pre><code>pip install snapy-toolbox\n</code></pre></p> <p>Only Runs on Windows and partial iOS</p> <p>On Windows only runs on python 3.11 &amp; 3.12, On iOS only runs on arm cpus and only on python 3.12</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>pandas &gt;= 1.5.3</li> <li>geopandas &gt;= 1.0.1</li> <li>pydeck &gt;= 0.8.0</li> <li>scipy &gt;= 1.10.0</li> <li>numpy &gt;= 1.23.5</li> <li>shapely &gt;= 2.0.0</li> </ul>"},{"location":"#how-to-use","title":"How to Use","text":"<p>As Spatial Network Analysis is a derivative development of the Social Science Network Analysis, the conceptualization of the network is adjusted where in the object, path network as the medium is supplemented by end nodes that represents buildings, activity points, or Point of interest of the movement. Note that the polygon data of the network pathway is required to be segmented at each intersection, with maximum inaccuracy tolarance of 1e-3 on junctions, further than that distance will not be detected as a junction. Entrance data are not required to be located on the network lines, as there are built in functions to map entrance points into the network. Per Function documentation can be accessed in Documentation Most analysis tools included will require a network, consisting of polygon geometry pathway networks, and point geometry entrances in any GIS format readable by geopandas. Some testdata is provided in this repository, which contains a part of Jakarta's network line obtained by OSM API, as the following:  </p> <p></p> <p>to use library, load data into geopandas geodataframe format, and use Graphsims to load the network information. It will compile and also append how the entrances connect to the network data.</p> <pre><code>import geopandas as gpd\nimport SNAPy as sna\n\ndfNetwork = gpd.read_file('NetworkClean.shp') # network dataframe\ndfEntries = gpd.read_file('Features.gpkg', layer='Features') # entrance dataframe\n\nnwSim = sna.GraphSims(dfNetwork, dfEntries) # main class for loading network data\n</code></pre> <p>to save the projected entries data, or access both network data or entrance data, both dataframes can be called and used as a normal Geopandas geodataframe</p> <pre><code>nwSim.EntriesDf.to_file(\"file.gpkg\", layer=\"entries\", driver=\"GPKG\", crs=\"EPSG:32748\") # saving entries dataframe\nnwSim.NetworkDf.to_file(\"file.gpkg\", layer=\"network\", driver=\"GPKG\", crs=\"EPSG:32748\") # saving network dataframe\n</code></pre> <p>Example analysis and result of the betweenness Patronage</p> <pre><code>nwSim.BetweenessPatronage(OriWgt='Capacity', DestWgt='Weight', DetourR=1.2, SearchDist=1200, AlphaExp=0.1, RsltAttr='BtwnP')\n</code></pre> <p>with the resulting nwSim.Gdf as displayed below, can be directly shown on jupyter using nwSim.Map_AddLayer('BtwnP') and nwSim.Map_Show()</p> <p> </p> <p>Performance is designed to be CPU optimized and RAM efficient, and more faster and reliable than former counterparts, but undeniably there are still a lot of room for development and streamlining process. Current build spends &lt;30% (&lt;60% on larger networks) of runtime within the pathfinding functions, SGACy, which is Cython based and quite optimized. Upon trial, using all cores of multithreading, process can be significantly faster than UNA Toolbox on Rhino and ArcGIS, upto 2 to 3 magnitude faster on runtime.</p> <p>Sample run of 141k entry points as origin-destination on a 74k edges as network. number of pairings near 141k^2 (about 19mil pairings), with search distance of 400m and DetourRatio of 1.1. Multithreading process on i7-13700K without overclocking, the process took about 88s.</p> <p> </p> <p>Further examples and use cases please check the Examples section</p>"},{"location":"#references","title":"References","text":"<ul> <li>Sevtsuk, A., &amp; Mekonnen, M. (2012). Urban Network Analysis Toolbox. International Journal of Geomatics and Spatial Analysis, 22(2), 287\u2013305.</li> <li>Sevtsuk, A. (2014). Networks of the built environment. In D. Ofenhuber &amp; C. Ratti (Eds.), Decoding the City: Urbanism in the Age of Big Data (p. 192). Birkh\u00e4user.</li> <li>Barrat, A., et al. (2004) The architecture of complex weighted networks</li> <li>Haggett, P., &amp; Chorley, J. C. (1969) Network Analysis in Geography. London: Butler &amp; Tanner Ltd.</li> <li>Freeman, Linton (1977) A set of measures of centrality based on betweenness, Sociometry.</li> <li>Sevtsuk, A (2010) Path and Place: A Study of Urban Geometry and Retail Activity in Cambridge and Somerville, MA.</li> <li>Dijkstra, E W (1959) A note on two problems in connexion with graphs.</li> </ul> <p> @September2024</p>"},{"location":"Pages/SGACy/","title":"Spatial Graph Analysis in Cython","text":"<p>SGACy is a specially developed library to perform efficient pathfinding and other related functions on a spatial graph using Cython. This level of optimization enables for Urban Network Analysis (UNA) in the scale of cities on an acceptable time/processing cost. Comparison tests with networkx results in 20-100x times faster for single pathfinding, and up to 3 to 4 magnitudes on alternative-pathfinding, which are crucial for detour ratios on some UNA's toolset.</p> <p>Work in Progress</p> <p>Contents of this page is still in progress</p> <p> @September2024</p>"},{"location":"Pages/about/","title":"About","text":"<p>SNAPy have been developed for larger, regional size network analysis that requires doumentation and reliablity. As factors and models for pedestrian movement grew more complicated, customizable and faster processing felt obtainable by developing a python library. As network analysis is gaining prominency, both in planning, assessing, and commercial needs, this library has the goal to provide spatial network analysis tools for more people, where Data, GIS, Spatial analyst alike; Either for specific analysis or embedded within some related service.</p> <p>Developed by Kevin Sutjijadi @2023</p>"},{"location":"Pages/func_ca/","title":"Other Analysis","text":"<p>further and additional analysis based of extrapolation and calculation from network analysis's results.</p>"},{"location":"Pages/func_ca/#supplemental-calculations-functions","title":"Supplemental Calculations Functions","text":""},{"location":"Pages/func_ca/#simtimedistribute-func","title":"SimTimeDistribute  func","text":"<code>SimTimeDistribute(Gdf: GeodataFrame, SetDt: nested tuple, spread: float =1.0, ApdAtt: string ='HrTrf_')</code> <p>returns GeoDataFrame object  GeoDataFrame of network segment traffic values</p> <p>Runs a set of skewed distribution to distribute one or more betweeness patronage results to form traffic intensity distribution over each segment. Method can be read further at [Methods]{https://github.com/kevinsutjijadi/SNAPyDocs/Methods/}. Will result in information of traffic per hour.</p> <p>result return</p> <p>results field on self.EntriesDf would be a concatenation of prefix-origin-destination-suffix string, which could have long characters. Saving the format as </p> <p>processing duration</p> <p>function is a singlethread processing which can take some time in larger models. Test smaller/single distrubutions ones first. </p>"},{"location":"Pages/func_ca/#parameters","title":"Parameters","text":"Gdf : GeoDataFrame required Geodataframe of network from betweeness patronage results, can use GraphSim.NetworkDf directly. Function will output/construct a different geodataframe, so that the origin won't change/appended. SetDt : Nested Tuple/list required <p>Nested tuple/list of distributions, can be from csv or other table format, but without columns. the following data are: BtwnP Field Names - location - Shape - Skew</p> <p>location, shape, and skew are parameters form [Skew Normal distribution]{https://en.wikipedia.org/wiki/Skew_normal_distribution}, which can be obtained from model building/regessions from observation or other second hand data.</p> Spread : float default 1.0 time spread of calculations in the integral, in the unit of hours. if 1.0, will results in total traffic per hour for each hour of the day, and 0.5 will results in total traffic per hour for each 30 min of the day. ApdAtt : string default 'HrTrf_' suffix for result columns."},{"location":"Pages/func_ca/#use-example","title":"Use Example","text":"<pre><code>sets = [\n    ['Btw_Commute', 8.0, 1, 0.8],\n    ['Btw_Activity', 12.0, 2.5, 1.1],\n    ['Btw_Commute', 17.0, 1.2, 1.05],\n]\n\nsp = 0.5\n\nrslt = sna.SimTimeDistribute(nwSim.NetworkDf, sets, spread=sp)\n</code></pre> <p> @October2023</p>"},{"location":"Pages/func_na/","title":"Spatial Network Analysis Functions","text":"<p>Network Analysis functions</p>"},{"location":"Pages/func_na/#graphsims-class","title":"GraphSims    class","text":"<code>GraphSims(NetworkDf:GeoDataFrame, EntriesDf:GeoDataFrame, **kwargs)</code> <p>The core process for spatial network analysis is operated/structured within the <code>Graphsims</code> Class, which reads Geopandas Geodataframe for entries and network data. The class initialization prepackages and compiles further processing and its subsequent results. main class for network analysis processing, initialization stage will have some heavy processes included. the processes in order</p> <ul> <li>checking if network and entrances are the same projection and is_geographic (in meters)</li> <li> <p>checking geometry type (linestring for network and points for entries. if network has multilinestring, it will convert the layer to linestring) if the input data does not meet required prerequisite above, the initialization process will stop and raise exceptions.</p> </li> <li> <p>initial compiling of network nodes (junction points), if more than 30% of nodes are deadends, initialization process will offer to segment lines on intersections (SNAPy.NetworkSegmentIntersections(NetworkDf))</p> </li> <li>adding Feature-ID of network and entrances as attribute if not found</li> <li>building graph on SGACy (Spatial Graph Analisis in Cython)</li> <li>building entries data, appending with entrance/relation to graph related information.</li> <li>appending point coordinate as attributes unto EntriesDf</li> </ul>"},{"location":"Pages/func_na/#parameters","title":"Parameters","text":"NetworkDf : GeoDataFrame Geopandas geodataframe of network data, containing edges in LineString data form. Can contain weight multiplier for costs and also vertex classification; with the default value for cost is geometrical length.  EntriesDf : GeoDataFrame Geopandas geodataframe of Entries data, containing nodes in Point data form. **kwargs : Dict/keys-values <p>Parameter arguments, that contain:</p> <ul> <li> <p><code>\"EntDist\" float</code>   default 100.0</p> <p>search distance to closest edge of network, further distanced entrances will not be accounted</p> </li> <li> <p><code>\"EntID\" string</code>   default \"fid\"</p> <p>string of attribute/column name for Entrance Feature ID. If not found, will be automatically made in initialization process</p> </li> <li> <p><code>\"EdgeID\" string</code>   default \"fid\"</p> <p>string of attribute/column name for Network Feature ID. If not found, will be automatically made in initialization process</p> </li> <li> <p><code>\"AE_Lnlength\" string</code>   default None</p> <p>string of attribute/column name for Network cost multiplier, if None, all edges will use the value of its geometrical length</p> </li> <li> <p><code>\"AE_LnlengthR\" string</code>   default None</p> <p>string of attribute/column name for Network cost in reverse multiplier, if None, all edges will use the value of 'AR_Lnlength'</p> </li> <li> <p><code>\"AE_EdgeCost\" string</code>   default None</p> <p>Additional cost multiplier, if None will revert to 1.0</p> </li> <li> <p><code>\"Threads\" int</code>   default 0</p> <p>specify threads number for multiprocessing. For single core processing, input 1. The default value is 0, if which, will be replaced with (CPU count - 1), which almost fully utilizes CPU processing.</p> </li> <li> <p><code>\"SizeBuffer\" float</code>   default 0.05</p> <p>buffer multipler for edges and nodes array size in GraphCy, only important if additional addition to edges or nodes are done during process.</p> </li> </ul>"},{"location":"Pages/func_na/#use-example","title":"Use Example","text":"<pre><code>import SNAPy as sna\nimport geopandas as gpd\n\ndfNetwork = gpd.read_file('testdata\\\\NetworkClean.shp') # network dataframe\ndfEntries = gpd.read_file('testdata\\\\Features.gpkg', layer='Features') # entrance dataframe\n\nnwSim = sna.GraphSims(dfNetwork, dfEntries) # main class for loading network data\n</code></pre>"},{"location":"Pages/func_na/#graphsims-items","title":"GraphSims Items","text":""},{"location":"Pages/func_na/#baseset-dict","title":".baseSet  dict","text":"<p>Dictionary of settings</p> <p>Dictionary of processing settings used in initialization or other functions. Complete elements of the dictionary can be read/found at class parameter description.</p>"},{"location":"Pages/func_na/#networkdf-geodataframe","title":".NetworkDf  GeoDataFrame","text":"<p>GeoDataFrame of network from input, with parity with edges data in SGACy graph.</p> <p>Functions that have results on edges such as .BetweenessPatronage, etc will save their results in a specified field name. Which then the variable can be obtained and modified as a GeoDataFrame, which can be edited, saved, filtered.</p>"},{"location":"Pages/func_na/#entriesdf-geodataframe","title":".EntriesDf  GeoDataFrame","text":"<p>GeoDataFrame of entries from input. From initialization process or reparametrization will be automatically appended intersection point coordinate as 'xPt_X' and 'xPt_Y', and 'xLn_ID' for connected edge id.</p> <p>built-in entries point based functions such as .Reach, etc will save their results in a specified field name. Which then the variable can be obtained and modified as a GeoDataFrame, which can be edited, saved, filtered.</p>"},{"location":"Pages/func_na/#gph-graph","title":".Gph  Graph","text":"networkx Graph object from class initialization or reparametrization"},{"location":"Pages/func_na/#nodedf-geodataframe","title":".NodeDf  GeoDataFrame","text":"GeodataFrame of network nodes, with the attribute 'JunctCnt', interger, of number of junctions/connections with edges of network. Will automatically initialize if used NetworkSegmentIntersections, but will be None initially. To access please use GraphSims.getNodes()."},{"location":"Pages/func_na/#pdklayers-pdklyrnm-pdkcenter","title":".pdkLayers, .pdkLyrNm, .pdkCenter","text":"Pydeck related values, see more at visualisation related variables"},{"location":"Pages/func_na/#graphsims-functions","title":"GraphSims Functions","text":"<p> @September2024</p>"},{"location":"Pages/func_na/#betweenesspatronage-func","title":".BetweenessPatronage  func","text":"<code>BetweenessPatronage(self, OriID:Tuple=None, DestID:Tuple=None, **kwargs)</code> <p>returns self.NetworkDf : GeoDataFrame  GraphSims.NetworkDf with the specified results column</p> <p>Function for betweeness patronage, calculating segment traffic weighting from origin capacity, distributed through weightable destinations within the network in a set distance. Further elaboration on the method can be accessed on method documentation. Output appended on network/edges data on self.NetworkDf, but results on entries-destination on self.EntriesDf can also be aqcuired with setting Include_Destination : True in kwargs.</p> <p>result return</p> <p>results will be appended to self.NetworkDf, therefore the results can be accesed later so that the function does not need to be assigned into a new variable.</p> <p>origin-destination pairings</p> <p>It is acceptable to have the same id in origins and destinations, as the algorithm will skip/pass the calculations if the origin and destination has the same id.</p> <p>processing duration</p> <p>Further distances will require exponentially longer time. Function has built in multithreading capabilities using multiprocessing.Pool. Please take notice of self.baseSet['Threads'], as the value is also used in this function.</p>"},{"location":"Pages/func_na/#parameters_1","title":"Parameters","text":"OriID : list, tuple, np.array, geoseries default None Set of registered IDs of entries acting as origins. Any iterable format that is compatible to geoDataFrame.isin() function. If None, all entries will be set as origins. DestID : list, tuple, np.array, geoseries default None Set of registered IDs of entries acting as destinations. Any iterable format that is compatible to geoDataFrame.isin() function. If None, all entries will be set as destinations. **kwargs : Dict/keys-values <p>Parameter arguments, that contain:</p> <ul> <li> <p><code>\"OriWgt\" string</code>   default 'weight'</p> <p>name of the attribute from self.EntriesDf to access weight value for origin points. In the context of Betweeness Patronage, the value will represent the trip unit/person. There is a feature that skips any processing if the weighting value is 0.0</p> <p>default values</p> <p>if the attribute name is not found, there will be an automatic adjustment/appandage with the default value of 1.0</p> </li> <li> <p><code>\"DestWgt\" string</code>   default \"weight\"</p> <p>name of the attribute from self.EntriesDf to access weight value for destination points. In the context of Betweeness Patronage, the value will represent destination preference. There is a feature that skips any processing if the weighting value is 0.0</p> <p>default values</p> <p>if the attribute name is not found, there will be an automatic adjustment/appandage with the default value of 1.0</p> </li> <li> <p><code>\"RsltAttr\" string</code>   default \"PatronBtwns\"</p> <p>Attribute name for the result. will be appended to self.NetworkDf. (And self.EntriesDf if Include_Destination set True)</p> </li> <li> <p><code>\"SearchDist\" float</code>   default 1200.0</p> <p>Search distance from origin to destination in network distance. Note that origin-destination pairings that are close to SearchDist and have DetourR that may result in distances further than SearchDist will still append the path found.</p> </li> <li> <p><code>\"DetourR\" float</code>   default 1.0</p> <p>detour ratio for redundant paths, the value will represent the maximum redundant/alternative path length from the shortest path within the maximum search distance. Default value is 1.0 which is provided a switch to only find one shortest path. (if two exact shortest path exist, the pathfinding algorithm will use the smalled FID edge number).</p> </li> <li> <p><code>\"AlphaExp\" float</code>   default 0.0</p> <p>Exponent value for inverse distance function. if using default value of 0.0, the calculation turns into a linear inverse distance function. See more at method documentation.</p> </li> <li> <p><code>\"AttrEdgeID\" string</code>   default self.baseSet['EdgeID']</p> <p>Edge ID attribute field name, default will be referring to self.baseSet['EdgeID'], which has a default of 'fid'.</p> </li> <li> <p><code>\"AttrEntID\" string</code>   default self.baseSet['EntID']</p> <p>Entry ID attribute field name, default will be referring to self.baseSet['EntID'], which has a default of 'fid'.</p> </li> <li> <p><code>\"Include_Destination\" bool</code>   default False</p> <p>Included distribution of origin weight on destination entries. Note that this will also create a new attribute/field on self.EntriesDf but it won't be included as an ouptut of this function. To access results use GraphSims.EntriesDf.</p> </li> <li> <p><code>\"Threads\" int|None</code>   default None</p> <p>number of threads for processing, if None, threads will refer to self.baseSet['Threads']. Note that this will set self.baseSet['Threads'], impacting other processes. Set 0 to automatically set cpu_count - 1</p> </li> <li> <p><code>\"PathLim\" int</code>   default 2000</p> <p>Number of alternative path between an origin-destination pair. Paths generated are already very close to be sorted by distance. Process stopped if number of found paths exceed PathLim, so that further paths within DetourR range will not be detected/skipped.</p> </li> </ul>"},{"location":"Pages/func_na/#use-example_1","title":"Use Example","text":"<pre><code>### continuation from class initialization\n### nwSim = sna.GraphSims()\n\n\nnwSim.BetweenessPatronage(OriWgt='Capacity', DestWgt='Weight', SearchDist=700, DetourR=1.1) # results does not need to be contained\nnwSim.NetworkDf.sample # results can be accessed from the NetworkDf attribute\n</code></pre> <p>Function can be run in loops</p> <pre><code>### continuation from class initialization\n### nwSim = sna.GraphSims()\n\nruns = (\n    ('Ent01', 'Dst02', 350.0, 1.0, 'run01'),\n    ('Ent02', 'Dst02', 700.0, 1.2, 'run02'),\n    ('Ent03', 'Dst03', 700.0, 1.0, 'run03'),\n)\n\nfor rn in runs:\n    nwSim.BetweenessPatronage(OriWgt=rn[0], DestWgt=rn[1], SearchDist=rn[2], DetourR=rn[3], RsltAttr=rn[4]) # results does not need to be contained\nnwSim.NetworkDf.to_file(\"output.gpkg\", layer=\"Entries\", crs=\"EPSG:32748\", driver='GPKG') # geoDataFrame can be saved to GIS files\n</code></pre>"},{"location":"Pages/func_na/#reach-func","title":".Reach  func","text":"<code>Reach(self, OriID:Tuple=None, DestID:Tuple=None, Mode:str='N', **kwargs)</code> <p>returns self.EntriesDf : GeoDataFrame  GraphSims.EntriesDf with the specified results column</p> <p>Function for Reach related calculations. Further elaboration on the method can be accessed on method documentation. With the resulting information are counts/weighted sums/sums of destinations within reach, the results can also be interpreted as Centralities. Further explanation on reach documentation can found on method documentation. Contains multiple Modes:</p> <ul> <li> <p>Mode=\"N\" : Count Sum     for counting destinations within reach distance, results in one new attribute of interger numbers</p> </li> <li> <p>Mode=\"W\" : Weighted Sum     for counting and summing value based on specific weights of each destination feature, results in two attribute (with the second has a suffix of \"_2\"). First is interger count, second is the summed weight</p> </li> <li> <p>Mode=\"WD\" : Weighted Distance Sum     for counting and summing value based on specific weights adjusted with distance function of each destination feature, results in two attribute (with the second has a suffix of \"_2\"). First is interger count, second is the summed weight.</p> <p>CalcExp Value</p> <p>CalcExp value is negative by default. It can handle negative </p> </li> <li> <p>Mode=\"ND\" : Count and Distance     for counting and finding nearest distance to destination. Results in two attribute (with the second has a suffix of \"_2\"). First is interger count, second is the minimum distance.</p> </li> <li> <p>Mode=\"NDW\" : Count, min Distance, and Weight Sum     for counting and finding nearest distance to destination, and also sum of weight to all destinations in reach. Results in three attribute (with the minimum distance suffix of \"_D\", and Weight Sum of \"_W\").</p> </li> </ul> <p>result return</p> <p>results will be appended to self.EntriesDf, therefore the results can be accesed later so that the function does not need to be assigned into a new variable.</p> <p>processing duration</p> <p>function has built in multithreading capabilities using multiprocessing.Pool. Please take notice of self.baseSet['Threads'], as the value is also used in this function. Larger models, larger search distance, will be cause exponentially longer processing time.</p>"},{"location":"Pages/func_na/#parameters_2","title":"Parameters","text":"OriID : Tuple default None Tuple of Origin point IDs, referencing <code>GraphSims.EntriesDf</code> ID attribute specified at class initialization. If None, all  DestID : Tuple default None Geopandas geodataframe of Entries data, containing nodes in lines/polylines data form. Can contain weight Mode : string default \"N\" modes of calculation, see function description. **kwargs : Dict/keys-values <p>Parameter arguments, that contain:</p> <ul> <li> <p><code>\"DestWgt\" string</code>   default \"weight\"</p> <p>name of the attribute from self.EntriesDf to access weight value for destination points. In the context of Betweeness Patronage, the value will represent destination preference. There is a feature that skips any processing if the weighting value is 0.0</p> <p>default values</p> <p>if the attribute name is not found, there will be an automatic adjustment/appandage with the default value of 1</p> </li> <li> <p><code>\"RsltAttr\" string</code>   default \"Reach\"</p> <p>Attribute name for the result. will be appended to self.NetworkDf.</p> </li> <li> <p><code>\"SearchDist\" float</code>   default 1200.0</p> <p>maximum path distance, corresponding to the data's units</p> </li> <li> <p><code>\"CalcExp\" float</code>   default 0.35</p> <p>Exponent value for inverse distance function. if using default value of 0.0, the calculation turns into a linear inverse distance function. only for \"WD\" mode.</p> </li> <li> <p><code>\"CalcComp\" float</code>   default 0.6</p> <p>Compunding multiplier for \"WD\" mode.</p> </li> <li> <p><code>\"Threads\" int|None</code>   default None</p> <p>number of threads for processing, if None, threads will refer to self.baseSet['Threads']. Note that this will set self.baseSet['Threads'], impacting other processes. Set 0 to automatically set cpu_count - 1</p> </li> </ul>"},{"location":"Pages/func_na/#use-example_2","title":"Use Example","text":"<pre><code>### continuation from class initialization\n### nwSim = sna.GraphSims()\n\n\nnwSim.Reach(Mode='WD\", SearchDist=700, CalcExp=0.1) # results does not need to be contained\nnwSim.EntriesDf.sample # results can be accessed from the EntriesDf attribute\n</code></pre>"},{"location":"Pages/func_na/#straightness-func","title":".Straightness  func","text":"<code>Straightness(self, OriID:list=None, DestID:list=None, Mode='A', **kwargs)</code> <p>returns self.EntriesDf : GeoDataFrame  GraphSims.EntriesDf with the specified results column</p> <p>Returns average of Straightness value from all objects is flight distance from origin point. Only accounts of objects with findable paths within the network. Untracable paths will not be accounted. Further elaboration on the method can be accessed on method documentation.</p> <p>result return</p> <p>results will be appended to self.EntriesDf, therefore the results can be accesed later so that the function does not need to be assigned into a new variable.</p> <p>processing duration</p> <p>function has built in multithreading capabilities using multiprocessing.Pool. Please take notice of self.baseSet['Threads'], as the value is also used in this function. Larger models, larger search distance, will be cause exponentially longer processing time.</p>"},{"location":"Pages/func_na/#parameters_3","title":"Parameters","text":"OriID : Tuple default None Tuple of Origin point IDs, referencing <code>GraphSims.EntriesDf</code> ID attribute specified at class initialization. If None, all  DestID : Tuple default None Geopandas geodataframe of Entries data, containing nodes in lines/polylines data form. Can contain weight **kwargs : Dict/keys-values <p>Parameter arguments, that contain:</p> <ul> <li> <p><code>\"DestWgt\" string</code>   default \"weight\"</p> <p>name of the attribute from self.EntriesDf to access weight value for destination points. In the context of Betweeness Patronage, the value will represent destination preference. There is a feature that skips any processing if the weighting value is 0.0</p> <p>default values</p> <p>if the attribute name is not found, there will be an automatic adjustment/appandage with the default value of 1</p> </li> <li> <p><code>\"RsltAttr\" string</code>   default \"Straightness\"</p> <p>Attribute name for the result. will be appended to self.NetworkDf.</p> </li> <li> <p><code>\"SearchDist\" float</code>   default 1200.0</p> <p>maximum path distance, corresponding to the data's units</p> </li> <li> <p><code>\"CalcExp\" float</code>   default 0.35</p> <p>Exponent value for inverse distance function. if positive will calculate by distance exponent, with further destinations will result in larger weights. use negative numbers for inverse distance function.</p> </li> <li> <p><code>\"Threads\" int|None</code>   default None</p> <p>number of threads for processing, if None, threads will refer to self.baseSet['Threads']. Note that this will set self.baseSet['Threads'], impacting other processes. Set 0 to automatically set cpu_count - 1</p> </li> </ul>"},{"location":"Pages/func_na/#use-example_3","title":"Use Example","text":"<pre><code>### continuation from class initialization\n### nwSim = sna.GraphSims()\n\n\nnwSim.Straightness(SearchDist=700, CalcExp=-0.1) # results does not need to be contained\nnwSim.EntriesDf.sample # results can be accessed from the EntriesDf attribute\n</code></pre>"},{"location":"Pages/func_na/#pathreach-func","title":".PathReach  func","text":"<code>PatyReach(self, OriID:list, distance:float=800, joined:bool=False, incl_nodes=False, showmap=False, skip_layerinit=True, pdkupdate=False, **kwargs)</code> <p>returns edges : GeoDataFrame </p> <p>Returns a new dataframe containing geometries of edges that are within the reach radius from each origin entry, where each feature in output will have an appended origin ID.</p> <p>multiple outputs!</p> <p>the arguments 'incl_nodes', 'showmap', 'pdkupdate' will result in different return data and types. Read more on parameter description</p>"},{"location":"Pages/func_na/#parameters_4","title":"Parameters","text":"OriID : Tuple default None iterable object of Origin Entry Ids. distance : float default 800 Distance limit of pathreach. Lines/edges will be split on this distance. joined : bool default False Joins lines from all origins. Note that this will override/exclude origin entry id from results. incl_nodes : bool default False Output includes nodes on intersection, containing distance from origin information. showmap : bool default False Outputs Pydeck Deck/Map as the first input. Shows the edges, nodes on intersection with labels of distance, and origin point. Note that there are still edges and node output also appended in output skip_layerinit : bool default True Skips .Map_BaseLayerInit, so that output map will not include lines and other entries. pdkupdate : bool default False Outputs a list of Pydeck.Layers to replace or update previous pydeck.deck for update/interactive visualization. See more on Samples **kwargs : Dict/keys-values Parameter arguments, empty."},{"location":"Pages/func_na/#use-example_4","title":"Use Example","text":"<pre><code>### continuation from class initialization\n### nwSim = sna.GraphSims()\n\nEdgesDf, NodeDf = nwSim.PathReach((1,), SearchDist=800, incl_nodes=True)\n# unlike other GraphSims functions, PathReach results are not contained within the class.\n</code></pre>"},{"location":"Pages/func_routines/","title":"Spatial Network Analysis Routine Functions","text":"<p>Built in aggregate functions for multiple runs of the network analysis tools</p>"},{"location":"Pages/func_routines/#routines-functions","title":"Routines Functions","text":""},{"location":"Pages/func_routines/#reachaggregate-func","title":"ReachAggregate  func","text":"<code>ReachAggregate(GraphSm:GraphSims, MeasureDf:pd.DataFrame, **kwargs)</code> <p>returns GraphSims : GraphSims class object  GraphSims object</p> <p>Runs a set of Reach functions available on the GraphSim functions. Reads the set of runs from a dataframe. See MeasureDf explanation for input sets. Outputs GraphSims with self.EntriesDf appended with results, with naming fill be</p> <p>result return</p> <p>results field on self.EntriesDf would be a concatenation of prefix-origin-destination-suffix string, which could have long characters. Saving the format as </p> <p>processing duration</p> <p>function has built in multithreading capabilities using multiprocessing.Pool. Please take notice of self.baseSet['Threads'], as the value is also used in this function. Larger models, larger search distance, larger detour ratio will be cause exponentially longer processing time.</p>"},{"location":"Pages/func_routines/#parameters","title":"Parameters","text":"GraphSm : GraphSim required GraphSim object, initialized, can also be from previous analysis runs. MeasureDf : DataFrame required <p>Pandas Dataframe of sets of runs. Make sure in format of columns: 'OriginField' - 'DestinationField' - SeachDistance - WeightField</p> <p>Note that OriginField and DestinationField columns are matching with the EntriesDF's column name. Example:</p> Function Function.1 Dist WeightField ResidentialV ShopFNB 1200 Capacity ResidentialV BusStop 400 Routes ShopFnB Office 700 GFA ShopFnB Office 1500 GFA <p>columns</p> <p>Note that the first and second columns names are matching the self.EntriesDf column names. its rows are the values of the features. Note that Pandas DataFrame cannot have matching/same column name, so if the keys for Origin and Destination are the same, the suffix of '.1' on the columns are appended, which is accounted in the functions.</p> <p>same destinations</p> <p>The resulting field is constructed from OptSuffix + DestinationField + OptPrefix, where OptSuffix and prefix can be accessed on the **kwargs settings. If there are 2 or more same destinations, the subsequent result names will be appended '_n', with n representing intergers.</p> **kwargs : Dict/keys-values <p>Parameter arguments, that contain:</p> <ul> <li> <p><code>\"OptSuffix\" string</code>   default ''</p> <p>suffix string for all output.</p> </li> <li> <p><code>\"OptPrefix\" string</code>   default \"weight\"</p> <p>prefix string for all outputs.</p> </li> </ul> <p>additional arguments</p> <p>Additional arguments can be added in this kwargs that are corresponding to the Reach's arguments. For example, CalcType, CalcComp, etc.</p>"},{"location":"Pages/func_routines/#use-example","title":"Use Example","text":"<pre><code>import SNAPy as sna\nimport geopandas as gpd\nimport pandas as pd\n\ndfNetwork = gpd.read_file('testdata\\\\NetworkClean.shp') # network dataframe\ndfEntries = gpd.read_file('testdata\\\\Features.gpkg', layer='Features') # entrance dataframe\n\nnwSim = sna.GraphSims(dfNetwork, dfEntries, settings)\n\ndfMeasures = pg.read_csv('testdata\\\\Measures.csv') # routine dataframe\n\nReachAggregate(nwSim, dfMeasures, OptSuffix='R1_', CalcType='NWD') # results does not need to be contained\n\nnwSim.NetworkDf.to_file(\"output.gpkg\", layer=\"Entries\", crs=\"EPSG:32748\", driver='GPKG') # geoDataFrame can be saved to GIS files\n</code></pre>"},{"location":"Pages/func_routines/#betweenesspaggregate-func","title":"BetweenessPAggregate  func","text":"<code>BetweenessPAggregate(GraphSm:GraphSims, PairsDf:DataFrame, MeasureDf:DataFrame=None, **kwargs)</code> <p>returns GraphSims : GraphSims class object  GraphSims object</p> <p>Runs a set of Reach functions available on the GraphSim functions. Reads the set of runs from a dataframe. See MeasureDf explanation for input sets. Outputs GraphSims with self.NetworkDf appended with results. PairsDf is required for iteration, but MeasureDf, which is used for interpolating to form simulation weights, does not; if left none, make sure the weight fields already exists on Graphsims.Entries.</p> <p>PairsDf and MeasureDf</p> <p>use the same column order as in the parameter documentation, it does not match keys!</p> <p>processing duration</p> <p>function has built in multithreading capabilities using multiprocessing.Pool. Please take notice of self.baseSet['Threads'], as the value is also used in this function. Larger models, larger search distance, larger detour ratio will be cause exponentially longer processing time.</p>"},{"location":"Pages/func_routines/#parameters_1","title":"Parameters","text":"GraphSm : GraphSim required GraphSim object, initialized, can also be from previous analysis runs. PairsDf : DataFrame required <p>Pandas Dataframe of sets of runs. Make sure in format of columns: Name - OriginWeightFields - DestinationWeightFields - SearchDistance - DetourR - AlphaExp*  * optional</p> <p>Note that OriginField and DestinationField columns are matching with the EntriesDF's column name. Example:</p> RsltName OriginWeightField DestinationWeightField Distance DetourR Commute_01 ComOr01 ComDes 1200 1.0 Commute_02 ComOr02 ComDes 700 1.1 Activity_01 Cap01 CapW01 700 1.5 Event_01 Stadium PT01 400 1.0 <p>SearchDistance, DetourR, and AlphaExp</p> <p>these settings are optional, with if columns is not found, will be using default values that can be declared on kwargs.</p> <p>column order</p> <p>Use the same column order as the documentation. Naming of those columns does not effect processing</p> MeasureDf : DataFrame default: None <p>Pandas Dataframe of sets of runs. Make sure in format of columns: 'TypeMatch' - BaseWeightField - *Extrapolated Fields</p> <p>For extrapolating columns for betweeness matching with PairsDf. DataFrame can be expanded to n columns/fields. Example:</p> Function WeightField ComOr01 ComDes Cap01 CapW01 ResidentialV Residents 0.8 0.0 0.5 0.5 ShopFNB Capacity 0.1 0.0 0.8 2.0 ShopFnB Capacity 0.1 0.0 0.8 2.0 BusStop RouteW 0 1.0 0.0 0.0 Office Capacity 0.8 0.0 0.6 0.6 <p>columns</p> <p>Note that the first column name should match the self.EntriesDf column names. its rows are the values of the features.</p> **kwargs : Dict/keys-values <p>Parameter arguments, that contain:</p> <ul> <li> <p><code>\"OptSuffix\" string</code>   default ''</p> <p>suffix string for all output.</p> </li> <li> <p><code>\"OptPrefix\" string</code>   default \"weight\"</p> <p>prefix string for all outputs.</p> </li> </ul> <p>additional arguments</p> <p>Additional arguments can be added in this kwargs that are corresponding to the Reach's arguments. For example, DetourR, AlphaExp, etc.</p>"},{"location":"Pages/func_routines/#use-example_1","title":"Use Example","text":"<pre><code>import SNAPy as sna\nimport geopandas as gpd\nimport pandas as pd\n\ndfNetwork = gpd.read_file('testdata\\\\NetworkClean.shp') # network dataframe\ndfEntries = gpd.read_file('testdata\\\\Features.gpkg', layer='Features') # entrance dataframe\n\nnwSim = sna.GraphSims(dfNetwork, dfEntries, settings)\n\ndfPairs = pg.read_csv('testdata\\\\Pairs.csv')\ndfMeasures = pg.read_csv('testdata\\\\Measures.csv') # routine dataframe\n\nBetweenessPAggregate(nwSim, dfPairs, dfMeasures) # results does not need to be contained\n\nnwSim.NetworkDf.to_file(\"output.gpkg\", layer=\"Entries\", crs=\"EPSG:32748\", driver='GPKG') # geoDataFrame can be saved to GIS files\n</code></pre> <p> @December2023</p>"},{"location":"Pages/func_structure/","title":"Module Structure","text":"<p>Urban Network Analysis requires some ammount of setup and data to intialize. As an adaptation from Network Analysis, spatial context need to be taken accounted, with the base information for any analysis requires the circulation network, represented by lines/edges, and Entries that are activity nodes or entrances are represented by points. During data entry, the points and network are not required to be connected or intersecting; As GraphSims will map the connection at the process of initialization.</p> <p></p> <p>The many branches of utility, use, and possible development of the set base features are numerous, with a lot of set/extrapolated metrics can be aquired/produced from the same/multiple calculation which also can be made from multiple calculation parameters.</p> <p> @January2024</p>"},{"location":"Pages/func_ut/","title":"Utility functions","text":"<p>utilities in geometry and processing, with parts that help on data preparation and several additional related utilitary functions.</p>"},{"location":"Pages/func_ut/#data-preparations-functions","title":"Data Preparations Functions","text":""},{"location":"Pages/func_ut/#networksegmentintersections-func","title":"NetworkSegmentIntersections  func","text":"<code>NetworkSegmenIntersections(df, dfi=None, EndPoints=True, tol=1e-3)</code> if EndPoints True (default), returns ndf : GeoDataFrame of segmented network pts : GeoDataFrame of endpoints and intersections if EndPoints False, returns ndf : GeoDataFrame of segmented network <p>Segments network lines on each intersection points as a part of data preparation for GraphSims class.</p> <p>result pts</p> <p>this result compiles all end points of segmented network lines, appending a new field named 'JnctCnt' as interger, with values of number of connected edges. To derive/detect dead ends, find JnctCnt that have 1 as value.</p> <p>indexing</p> <p>The process will explode multilinestrings and split lines. Index will be reset, but other fields from the original feature are kept.</p> <p>processing duration</p> <p>function does not have built in multithread processing, but as most of the process are vectorized numpy operations and sindex, on small to medium models, runtime remains acceptable (&lt;10). Larger models will have somewhat exponential duration. i.e., osm roadlines with 42k features took about 50s on a decent computer.</p>"},{"location":"Pages/func_ut/#parameters","title":"Parameters","text":"df : GeoDataFrame required Geopandas GeoDataFrame object, of unsegmented network. EndPoints : Boolean default:True Switch for the function to calculate and return pts. If False the pts result will return an empty list. tol : int default:3 Tolerance level in power of 10^-1, with the default value of 3 will round/collect connected edges within 0.001 of projection unit."},{"location":"Pages/func_ut/#use-example","title":"Use Example","text":"<pre><code>import SNAPy as sna\nimport geopandas as gpd\n\ndfNetwork = gpd.read_file('testdata\\\\Network.gpkg') # network dataframe\n\ndfNetworkSg, IxPts = sna.NetworkSegmentIntersections(dfNetwork)\n\ndfNetworkSg.to_file(\"SegmentedNetwork.gpkg\", layer=\"Network\", crs=\"EPSG:32748\", driver='GPKG') # geoDataFrame can be saved to GIS files\ndfNetworkSg.to_file(\"SegmentedNetwork.gpkg\", layer=\"Points\", crs=\"EPSG:32748\", driver='GPKG')\n\nnwSim = sna.GraphSims(dfNetworkSg, dfEntries, settings) # segmented lines to Graphsims\n</code></pre>"},{"location":"Pages/func_ut/#networksegmentdistance-func","title":"NetworkSegmentDistance  func","text":"<code>NetworkSegmentDistance(df, dist:float=50.0)</code> returns ndf : GeoDataFrame of segmented network <p>Segments network lines to an approximate length according to projection units. I.e. a \"meter\" unit projection, where a line is 150m, with \"dist\" distance variable of 50m, it will seperate the line into 3 segments.</p> <p>Minimum length and segmentation rounding</p> <p>line lengths less than 1.5x than the segment distance will not be segmented. Segmentation rounding uses modulus operation to determine number of segments.</p> <p>Does not segment intersection</p> <p>Recommended to use this function AFTER using NetworkSegmentIntersection. Note that segmenting network into smaller segments will cause some/major computing time for any analysis.</p>"},{"location":"Pages/func_ut/#parameters_1","title":"Parameters","text":"df : GeoDataFrame required Geopandas GeoDataFrame object, of a network. dist : float default:50 float distance for base network segment distance."},{"location":"Pages/func_ut/#use-example_1","title":"Use Example","text":"<pre><code>import SNAPy as sna\nimport geopandas as gpd\n\ndfNetwork = gpd.read_file('testdata\\\\Network.gpkg') # network dataframe\n\ndfNetworkSg, IxPts = sna.NetworkSegmenIntersections(dfNetwork)\n\ndfNetworkSg2 = sna.NetworkSegmentDistance(dfNetworkSg, 100) # Segmented by target distance of 100m\n\ndfNetworkSg2.to_file(\"SegmentedNetwork.gpkg\", layer=\"Network\", crs=\"EPSG:32748\", driver='GPKG') # geoDataFrame can be saved to GIS files\n\nnwSim = sna.GraphSims(dfNetworkSg, dfEntries, settings) # segmented lines to Graphsims\n</code></pre> <p> @September2024</p>"},{"location":"Pages/func_vis/","title":"Visualization functions","text":"<p>Some basic visualization functions based on pyDeck framework. functions and method stated below are part of GraphSims class.</p>"},{"location":"Pages/func_vis/#graphsims-functions","title":"GraphSims Functions","text":""},{"location":"Pages/func_vis/#map_show-func","title":"Map_Show  func","text":"<code>Map_Show(show='base', map_style='light', height=500, width=500, viewZoom=17, viewCenter=None)</code> <p>returns pydeck.bindings.deck.Deck pydeck.deck.Deck map</p> <p>Builds, compiles, and returns pydeck interactive map of the network. it compiles all pydeck.bindings.layer.Layer kept on GraphSims.pdkLayers. Function can be directly used, it will run GraphSims.Map_BaseLayerInit() if no layers on GraphSims.pdfLayers are detected.</p> <p>Showing Map</p> <p>On jupyter environment, map can be directly shown if the last line of the cell is GraphSims.Map_Show(). Or, result can be kept as variable and shown with Deck.show() or further manipulation of the pydeck object.</p>"},{"location":"Pages/func_vis/#parameters","title":"Parameters","text":"show : str default 'base' options of map shown, a shortcut for GraphSims.Map_LayerAdd. other case 'junction' to run GraphSims.AddLayer('junction') to show junctions internally. map_style : str default 'light' options of pydeck basemaps. height : int default 500 pydeck display height size width : int default 100% pydeck display width size in percent viewZoom : int default 17 pydeck display view zoom viewCenter : None|list default None pydeck view center, list/tuple of size two floats, in lon, lat coordinates in degrees"},{"location":"Pages/func_vis/#use-example","title":"Use Example","text":"<pre><code>nwSim = sna.GraphSims(dfNetworkSg, dfEntries, settings) # graphsim init\n\nnwSim.Map_Show()\n</code></pre> on jupyter this cell will show the map Example of default 'base' results:  <pre><code>nwSim = sna.GraphSims(dfNetworkSg, dfEntries, settings) # graphsim init\n\nmapDeck = nwSim.Map_Show(base='junction')\nmapDeck.to_html('foo.html')\nmapDeck.show()\n</code></pre> Example map result for 'junction', note that dead ends are labelled red, and the shown numbers are the numbers of connected edges.  Accessing pydeck.bindings.deck.Deck for further capabilities."},{"location":"Pages/func_vis/#map_layeradd-func","title":"Map_LayerAdd  func","text":"<code>def Map_LayerAdd(self, layers:dict)</code> <p>returns void Add specified attribute and compiles to GraphSims.pdkLayers, with options for visualizations. to show map use Graphsims.Map_Show(). Will initialize Graphsime.Map_BaseLayerInit()</p> <p>Same Attribute/Field name on Network and Entries dataframes</p> <p>Some simulations/analysis adds attributes to both network and entries dataframe. Due to procurement of layer by using attribute name, both entries and network will be appended. to remove one of them, use pop.(the index of the layer) in Graphsims.pdkLayers and Graphsims.pdkLyrNm</p>"},{"location":"Pages/func_vis/#parameters_1","title":"Parameters","text":"layers : dict required Dictionary of key items are layers, and values of settings. For default view settings use None as value. (i.e. {'Btwn':None}) the value are also in dictionary format, with settings available: 'label' : bool default: True- to turn on/of labels of values 'labelsize': int default: 9- size of label in points 'colors': list/str default: 'viridis'color ramp in 2d list of rgb, or string 'viridis' or 'spectral' for feature symbology 'vmin': None/float default: None- lower bound value for symbology distribution 'vmax': None/float default: None- upper bound value for symbology distribution 'distribution': str default: 'decile'- distribution by 'linear', 'quantile', or 'decile' 'Omin': float default: 1.0- lower bound value for symbology size (for lines and points) 'Omax': float default: 5.0- upper bound value for symbology size (for lines and points)"},{"location":"Pages/func_vis/#use-example_1","title":"Use Example","text":"<pre><code>nwSim = sna.GraphSims(dfNetworkSg, dfEntries, settings) # graphsim init\n\n# adding layer\nnwSim.Map_AddLayer(\n    {\n        'junction':None,\n        'Btwn':{'label':True, 'colors':'spectral', 'vmax':3000.0}\n    }\n)\n\nnwSim.Map_Show()\n</code></pre> Example of betweeness results, with parameters set above."},{"location":"Pages/func_vis/#related-itemsvalues-in-graphsims-to-mapping","title":"Related items/values in GraphSims to Mapping","text":"<p> @September2024</p>"},{"location":"Pages/func_vis/#pdklayers-list","title":".pdkLayers  list","text":"<p>list of pydeck Layer</p> <p>Compiled layers for pydeck visualization.</p>"},{"location":"Pages/func_vis/#pdklyrnm-list","title":".pdkLyrNm  list","text":"<p>list of pydeck Layer names</p> <p>For NetworkDf based layers have '_Ntw' suffix, with label layers have '_NtwLbl' suffix For EntriesDf based layers have '_Ent' suffix, with label layers have '_EntLbl' suffix </p>"},{"location":"Pages/func_vis/#pdkcenter-shapelypoint-in-degrees-epsg4326","title":".pdkCenter  Shapely.Point in degrees (epsg:4326)","text":"Center point for initial view center, on GraphSims.Map_BaseLayerInit(), coordinates will center on network df center using geopandas GeoDataFrame.geometry.unary_union.centroid."},{"location":"Pages/methods/","title":"Method Documentation","text":"<p>Documentation of calculation and processing methods used for the functions.</p>"},{"location":"Pages/methods/#reach-functions","title":"Reach Functions","text":"<p>Reach function and its derivatives are summation/compilations of destinations within a given distance limit. This is used to represent the total (by number or by weight) from each origin points to selected destination points, determining what type of features are reachable and how many options there are.</p>"},{"location":"Pages/methods/#reach-count","title":"Reach Count","text":"<p>The most basic form of the Reach function is the Reach Count, or mode 'N' in the library. Use for collecting the number of destinations options from origin point.</p> <p></p> <p>where jk are pairs of origin-destinations within the network graph G, and djk which represents distance of travel within the graph compared less than or equal to the distance limit of D.</p>"},{"location":"Pages/methods/#reach-weight-sum","title":"Reach Weight Sum","text":"<p>Reach Sum function which can be accessed with mode 'W' in the library, are reach function that returns the sum of a corresponding field value.<sup>1</sup></p> <p></p> <p>where in the condition of jk are pairs of origin-destinations within the network graph G, and djk which represents distance of travel within the graph compared less than or equal to the distance limit of D, the Wk Weight of the destination is summed.</p>"},{"location":"Pages/methods/#reach-inverse-weight-distance-with-marginal-utility","title":"Reach Inverse Weight Distance with Marginal Utility","text":"<p>Reach calculation function that applies weight sum accompanied with inverse weight distance and marginal utility. Developed for calculating weight with inverse distance (linear and exponent flexibility)<sup>2</sup> as well as incorporating marginal utility<sup>3</sup> concept.</p> <p></p> <p>where the condition for summation are pairs of origin-destinations (jk) within the network graph G, and djk which represents distance of travel within the graph compared less than or equal to the distance limit of D, that are sorted ascending based on pair distance, where also the loop index (n) is less than or equal to loop limit of N. </p> <p>To which the value for summation are the Wk Weight of the destination multiplied by normalized inverse distance with exponent component where \u03b1 represents the exponent factor, followed by marginal multiplier (\u03bc) to the power of its index (n).</p> <p>The function's additional utilities can be simplified wether to incorporate exponent of inverse distance and/or marginal utility, where the \u03b1 value can be set to 0 to set the inverse distance funtion to linear; And \u03bc can be set to 1 to disregard marginal utility.</p>"},{"location":"Pages/methods/#straightness-functions","title":"Straightness Functions","text":"<p>Straightness function represents the ratio between fly/cartesian distance over network distance to represent how direct a the shortest distance between origin and destinations are<sup>4</sup>, with values closer to 1.0 means a more direct network, where as smaller values represents more convoluted paths. The base function for straightness in the library is expressed in weighted average.</p> <p></p> <p>where in the condition of jk are pairs of origin-destinations within the network graph G, and dfjk which represents distance of cartesian distance compared less than or equal to the distance limit of D, the Wk Weight of the destination multiplied by flight distance over network distance (djk) is summed. Which as a part of weighted sum is devided by the sum of destination weight with the same sum condition.</p> <p>variations of the function that are available in distance weighted and also inverse distance weighted, with the following elaboration:</p>"},{"location":"Pages/methods/#straightness-distance-weight","title":"Straightness Distance Weight","text":"<p>Distance weight functions to express higher weighting on further objects, where the scores of further objects in network are weighted higher in proportion to the search distance. Applied on the base function with the expression as</p> <p></p> <p>where the distance weighting is based upon the network distance rather than the cartesian distance to emphasize further values.</p>"},{"location":"Pages/methods/#straightness-inverse-distance-weight","title":"Straightness Inverse Distance Weight","text":"<p>Inverse distance weight functions to express higher weighting on closer objects, where the scores of closer objects in network are weighted higher in proportion to the search distance. Applied on the base function with the expression as</p> <p></p> <p>where the distance weighting is based upon the network distance rather than the cartesian distance to emphasize further values.</p>"},{"location":"Pages/methods/#betweeness-patronage-functions","title":"Betweeness Patronage Functions","text":"<p>Betweeness Patronage is a weighted form of betweeness, where betweeness is a function for calculating number of paths going through a segment; Expressing how many paths going through that particular segment<sup>5</sup>. the patronage element expresses that function with weighted elements of the total sum of distributed value from the origin, with weighted preference to set of destinations through their distance and weight.</p> <p>Calculating basic discrete footfall can be defined from the origin, how much capacity or discrete users it generates, plot their course into a set of destinations, each with different attraction weighting, and also the distances they have to cover to reach it on the circulation network. the closer the distance, the more luring it is, but with enough intrinsic attractiveness weighting, further features can also outweigh closer ones. To express this in mathematical terms, there are several factors and concepts to combine.</p> <p></p> <p>where the sum from origin (j) in the set of origins (J) of the distributed value/patronage/capacity (pj). Multiplied by the weight ammount passing through the segment over the whole set of paths which is calculated by the sum of destination weights (Wk) over a distance multiplier of shortest distance between origin and destination (djk min) over the path distance (djk) in the power of 1 + exponent multiplier of \u03b1.</p> <p>Where the resulting value is the sum of function of paths that includes the segment divided by function of all possible paths, multiplied by the origin\u2019s weight. Meaning, that segments on all part of possible path alternative will equate up to complete weight, that proves the function. Alternative paths, also known as detour ratio, is expressed by a float value of at least more than 1.0, where alternative pathways are still less than the closest path times detour ratio is still included in the summation.</p> detour ratios and multiple destinations <p>By adding detour ratio of 1.5 with exponent of 0.1, the results of the function branches into multiple paths, with the furthest distance taken is limited to 1.5 times of the shortest path found.</p> <p>As for multiple destinations, and different weight comes into play, although the smaller weighted destination is closer, most (60%) of walks are directed into the further located destination. There are some segments that houses multiple paths towards multiple destinations, which is summed as stated in the mathematical function.</p>"},{"location":"Pages/methods/#time-distribution-functions","title":"Time Distribution Functions","text":"<p>From Betweeness Patronage, a movement set can be somewhat determined, i.e. morning commute to available public transport, schools, etc. But this movement happen on a spread of time. Varying movement sets such as office-parking, commercial-parks, etc. have their spread and common distribution throughout the day (Sevtsuk, 2021). Another example can be obtained in real time, where on Melbourne, some corridors provide real-time pedestrian count data, and it shows that the spread of these movement have common peaks, and can be different on different locations depending on its location,</p> <p>The spread of this sets of movement, as most statistical distribution are on the natural world, is made from numerous overlapping and maybe even interacting asymmetrical distribution. As the total movement set amount is known, skewed normal distribution suits this context best (Azzalini, Capitanio, 2014), Since there are multiple movement sets, some summation function will also be applied. Furthermore, as the desired readability of results, the output value can be expressed in the amount of movement per a range of time, such as hour or several minutes, which the resulting function as</p> <p></p> <p>Where the sum from m movement form a set of movements (M) of an integral within the range of time of the Pm(i) the segment's traffic of the movement on a nomal skew distribution function of that movement.</p> <p>Further explanation on some contents can be found at: SNAPyDocs methods</p> <p> @November 2023</p> <ol> <li> <p>Concept and function is similar to Reach Centrality, Sevtsuk A., Meckonnen M. (2012), which also adopts from Bath, Handy et al. (2002) applied on network rather than Euclidian space.\u00a0\u21a9</p> </li> <li> <p>from Franke (1982), adjusted from euclidean to network distance context.\u00a0\u21a9</p> </li> <li> <p>Expressing subsequent values would diminish in added weighting, following marginal utility principal from F.Y. Edgeworth (1981).\u00a0\u21a9</p> </li> <li> <p>from Vragovic, Louis et al. (2005) and Porta et al (2005)\u00a0\u21a9</p> </li> <li> <p>from Freeman (1977), expressing the importance of an edge in a network.\u00a0\u21a9</p> </li> </ol>"},{"location":"Pages/smpl/","title":"Sample Cases","text":"<p>utilities in geometry and processing</p>"},{"location":"Pages/smpl/#introduction","title":"Introduction","text":"<p>Introduction and basic use of library: Sample Use Jupyter Encompassing data loading, visualizing, analysis, and result documentation.</p>"},{"location":"Pages/smpl/#sample-uses","title":"Sample Uses","text":""},{"location":"Pages/smpl/#pathreach-visualization","title":"PathReach visualization:","text":"<p>PathReach Jupyter GraphSims.PathReach can be used in conjuction with ipywidget to create interactive analysis</p> <p> @September2024</p>"}]}